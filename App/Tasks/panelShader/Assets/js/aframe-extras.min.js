	"use strict";

		function n(e) {
			return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
		}
		var r = {
			once: VATS.LoopOnce,
			repeat: VATS.LoopRepeat,
			pingpong: VATS.LoopPingPong
		};


	AFRAME.registerComponent("animation-mixer", {
			schema: {
				clip: {
					default: "*"
				},
				duration: {
					default: 0
				},
				clampWhenFinished: {
					default: !1,
					type: "boolean"
				},
				crossFadeDuration: {
					default: 0
				},
				loop: {
					default: "repeat",
					// oneOf: Object.keys(r)
				},
				repetitions: {
					default: 1 / 0,
					min: 0
				},
				timeScale: {
					default: 1
				}
			},
			init: function() {
				console.log("aala re mixer")
				var e = this;
				this.model = null, this.mixer = null, this.activeActions = [];
				var t = this.el.getObject3D("mesh");
				// var t = this.el.object3D;
				t ? this.load(t) : this.el.addEventListener("model-loaded", function(t) {
					// console.log("asfdfsd sdf dfs")
					e.load(t.detail.model)
				})
			},
			load: function(e) {
				console.log(e)
				var t = this.el;
				this.model = e, this.mixer = new VATS.AnimationMixer(e), this.mixer.addEventListener("loop", function(e) {
					t.emit("animation-loop", {
						action: e.action,
						loopDelta: e.loopDelta
					})
				}), this.mixer.addEventListener("finished", function(e) {
					t.emit("animation-finished", {
						action: e.action,
						direction: e.direction
					})
				}), this.data.clip && this.update({})
			},
			remove: function() {
				this.mixer && this.mixer.stopAllAction()
			},
			update: function(e) {
				if (e) {
					var t = this.data,
						i = AFRAME.utils.diff(t, e);
					if ("clip" in i) return this.stopAction(), void(t.clip && this.playAction());
					this.activeActions.forEach(function(e) {
						"duration" in i && t.duration && e.setDuration(t.duration), "clampWhenFinished" in i && (e.clampWhenFinished = t.clampWhenFinished), ("loop" in i || "repetitions" in i) && e.setLoop(r[t.loop], t.repetitions), "timeScale" in i && e.setEffectiveTimeScale(t.timeScale)
					})
				}
			},
			stopAction: function() {
				for (var e = this.data, t = 0; t < this.activeActions.length; t++) e.crossFadeDuration ? this.activeActions[t].fadeOut(e.crossFadeDuration) : this.activeActions[t].stop();
				this.activeActions.length = 0
			},
			playAction: function() {
				if (this.mixer) {
					var e = this.model,
						t = this.data;
						var i = e.animations || (e.geometry || {}).animations || [];
						console.log(e,i);
					if (i.length)
						for (var o, s = function(e) {
								return new RegExp("^" + e.split(/\*+/).map(n).join(".*") + "$")
							}(t.clip), a = 0; o = i[a]; a++)
							if (o.name.match(s)) {
								var c = this.mixer.clipAction(o, e);
								c.enabled = !0, c.clampWhenFinished = t.clampWhenFinished, t.duration && c.setDuration(t.duration), 1 !== t.timeScale && c.setEffectiveTimeScale(t.timeScale), c.setLoop(r[t.loop], t.repetitions).fadeIn(t.crossFadeDuration).play(), this.activeActions.push(c)
							}
				}
			},
			tick: function(e, t) {
				this.mixer && !isNaN(t) && this.mixer.update(t / 1e3)
			}
		})